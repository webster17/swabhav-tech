1.	Understand DRY(Dont repeat yourself) with an example & also understand where we can elemenate it.
		Principle -	Don't Repeat Yourself
		- A basic strategy for reducing complexity to managable units is to divide a system into pieces.
		- The DRY principle states that these small pieces of knowledge may only occur exactly once in your entire system.
		- Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.
		- If the database credentials change, we will have to change the snippet(Part of a code)
		- DRY is a philosophy that packages logic into representations.
		- The simplest explanation tends to be the right one.
		- Coding is about building things.

		Advantages:
		- Maintainability
		- Readability
		- Reuse
		- cost
		- Testing

		DRY: In software engineering, Don't Repeat Yourself (DRY) or Duplication is Evil (DIE) is a principle of software development
		KISS: KISS is an acronym for the design principle "Keep it simple, Stupid!".
		SOLID: The principles when applied together intends to make it more likely that a programmer will create a system that is easy to maintain and extend over time

		WET(Write everything twices)


2.	Program execution takes place in java & compiler design.
		Edit Compile Load Verify and Execute

		Edit - Here the programmer uses a simple editor or a notepad application to write the java program and in the end give it a .java extension

		Compile - In this step the programmer gives the javac command and the .java files are converted into bytecode which is the language understood by the java virtual machine (and this is what makes java platform independent language). Any compile time errors are raised at this step

		Load - The program is then loaded into memory. This is done by the class loader which takes the .class files containing the bytecode and stores it in the memory. The .class file can be loaded from your hard disk or from the network as well

		Verify - the bytecode verifier checks if the bytecode loaded are valid and do not breach java's security restrictions

		Execute - The JIT (Just-in-Time) compiler compiles the program one bytecode at a time and runs the program


3.	What is stack, heap and basic algorithms.
		Java Heap space - is used by java runtime to allocate memory to Objects and JRE classes. Whenever we create any object, it's always created in the Heap space. Garbage Collection runs on the heap memory to free the memory used by objects that doesn't have any reference. Any object created in the heap space has global access and can be referenced from anywhere of the application.

		Java Stack - memory is used for execution of a thread. They contain method specific values that are short-lived and references to other objects in the heap that are getting referred from the method.
		Stack memory is always referenced in LIFO (Last-In-First-Out) order. Whenever a method is invoked, a new block is created in the stack memory for the method to hold local primitive values and reference to other objects in the method.

		Difference:
		1.	Heap memory is used by all the parts of the application whereas stack memory is used only by one thread of execution.
		2.	Whenever an object is created, it’s always stored in the Heap space and stack memory contains the reference to it. Stack memory only contains local primitive variables and reference variables to objects in heap space.
		3.	Objects stored in the heap are globally accessible whereas stack memory can’t be accessed by other threads.
		4.	Memory management in stack is done in LIFO manner whereas it’s more complex in Heap memory because it’s used globally. Heap memory is divided into Young-Generation, Old-Generation etc, more details at Java Garbage Collection.
		5.	Stack memory is short-lived whereas heap memory lives from the start till the end of application execution.
		6.	We can use -Xms and -Xmx JVM option to define the startup size and maximum size of heap memory. We can use -Xss to define the stack memory size.
		7.	When stack memory is full, Java runtime throws java.lang.StackOverFlowError whereas if heap memory is full, it throws java.lang.OutOfMemoryError: Java Heap Space error.
		8.	Stack memory size is very less when compared to Heap memory. Because of simplicity in memory allocation (LIFO), stack memory is very fast when compared to heap memory.


4.	Create class Student with methods and TestStudent with main method to display students resume.
		Program:
			package com.techlabs.array;

			import java.text.SimpleDateFormat;
			import java.util.Date;
			import java.math.BigInteger;
			import java.text.ParseException;

			class Student {
				String name, address, emailId, gender;
				Date dob;
				BigInteger contactNo;

				public void getData(String name, String address, Date dob, String emailId, BigInteger contactNo, String gender) {
					this.name = name;
					this.address = address;
					this.dob = dob;
					this.emailId = emailId;
					this.contactNo = contactNo;
					this.gender = gender;
				}

				public void buildResume() {
					System.out.println("Resume: \n***************************************************** \nName: " + name +
									"\nAddress: " + address +
									"\nGender: " + gender +
									" \nDate of Birth: " + new SimpleDateFormat("dd/MM/yyyy").format(dob) +
									" \nEmail ID: " + emailId +
									" \nContact No: " + contactNo +
									" \n*****************************************************");
				}
			}

			public class TestStudent {
				public static void main(String args[]) throws ParseException {
					Student stud = new Student();
					stud.getData("Santosh", "Dahisar (E)", new SimpleDateFormat("dd/MM/yyyy").parse("30/11/1995"), "santoshdangodra@gmail.com",
							new BigInteger("7666605343"), "Male");
					stud.buildResume();
				}
			}


5.	Understand 6 to 11 chapters from java edition Head First.